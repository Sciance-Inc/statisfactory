:py:mod:`statisfactory.IO.artifacts.artifact_interactor`
========================================================

.. py:module:: statisfactory.IO.artifacts.artifact_interactor

.. autoapi-nested-parse::

   implements various data interactor the catalog can delegates the saving / loading to.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   statisfactory.IO.artifacts.artifact_interactor.DynamicInterpolation
   statisfactory.IO.artifacts.artifact_interactor.MixinParseInterpolate
   statisfactory.IO.artifacts.artifact_interactor.ArtifactInteractor
   statisfactory.IO.artifacts.artifact_interactor.FileBasedInteractor
   statisfactory.IO.artifacts.artifact_interactor.CSVInteractor
   statisfactory.IO.artifacts.artifact_interactor.XLSXInteractor
   statisfactory.IO.artifacts.artifact_interactor.PicklerInteractor
   statisfactory.IO.artifacts.artifact_interactor.ODBCInteractor
   statisfactory.IO.artifacts.artifact_interactor.DatapaneInteractor
   statisfactory.IO.artifacts.artifact_interactor.BinaryInteractor
   statisfactory.IO.artifacts.artifact_interactor.FeatherInteractor




.. py:class:: DynamicInterpolation(template)

   Bases: :py:obj:`string.Template`

   Implements the interpolation of the !{} for the artifact values.

   Override the default template to :
       * replace the $ used by the StaticInterpolation with ! (the @ might be used in connection string)
       * disallow interpolation of non braced values.

   .. py:attribute:: delimiter
      :annotation: = !

      

   .. py:attribute:: pattern
      :annotation: = Multiline-String

       .. raw:: html

           <details><summary>Show Value</summary>

       .. code-block:: text
           :linenos:

           
               \!(?:
                 (?P<escaped>\!) |
                 {\s*(?P<named>[_a-z][_a-z0-9]*)\s*} |
                 {\s*(?P<braced>[_a-z][_a-z0-9]*)\s*} |
                 (?P<invalid>)
               )
               

       .. raw:: html

           </details>

      


.. py:class:: MixinParseInterpolate(*args, **kwargs)

   Implements helpers to interpolate a string and potentialy parse-it

   Implement the +{ }+ syntax to flag string to be evaluated (lit.)

   .. py:attribute:: pattern
      

      

   .. py:method:: interpolate_and_parse(self, string, **kwargs)

      Interpolate and parse a given string using the provided context


   .. py:method:: _evaluate_string(self, string)

      Evaluate a given string using the provided context


   .. py:method:: _interpolate_string(self, string, **kwargs)

      Interpolate a given string using the provided context



.. py:class:: ArtifactInteractor(artifact, *args, session: statisfactory.session.BaseSession, **kwargs)

   Bases: :py:obj:`statisfactory.logger.MixinLogable`, :py:obj:`MixinParseInterpolate`

   Describe the Interactor's interface.
   An interactor wraps the loading and saving operations of a Artifact.
   The user can implements custom interactors. To do so, the user should
   implements the interface desbribes in this class. An artifact and a Session object
   are available when the artifact is called by the Catalog.

   Validation of the Extra parameter is possible through the definition of an inner class named Extra.
   The inner class schould be a pydantic dataclasse or a pydantic base model to allow for automatic validation.

   .. py:attribute:: Extra
      

      

   .. py:attribute:: _interactors
      

      

   .. py:method:: __init_subclass__(cls, interactor_name, register: bool = True, **kwargs)
      :classmethod:

      Implement the registration of a child class into the artifact class.
      By doing so, the ArtifactInteractor can be extended to use new interactors without updating the code of the class (Open Close principle)
      See PEP-487 for details.


   .. py:method:: _dispatch(self, callable: Callable, **kwargs) -> Dict[str, Any]

      Dispatch the variadic arguments the callable.

      Args:
          callable (Callable): The callable to dispatch arguments to.


   .. py:method:: interactors(cls)
      :classmethod:


   .. py:method:: load(self, **kwargs) -> Any
      :abstractmethod:

      Return the underlying asset.


   .. py:method:: save(self, asset: Any, **kwargs)
      :abstractmethod:

      Save the underlying asset.



.. py:class:: FileBasedInteractor(artifact, *args, session: statisfactory.session.BaseSession = None, **kwargs)

   Bases: :py:obj:`ArtifactInteractor`

   Extend the Artifact Interactor with Path interpolations

   .. py:class:: Extra

      .. py:attribute:: path
         :annotation: :str

         


   .. py:method:: _put(self, payload: bytes, **kwargs)

      Put the payload to the URI

      Args:
          payload (BytesIO): The payload encoded as BytesIO to push.


   .. py:method:: _get(self, **kwargs) -> bytes

      Get a payload from the URI



.. py:class:: CSVInteractor(artifact, *args, session: statisfactory.session.BaseSession = None, **kwargs)

   Bases: :py:obj:`FileBasedInteractor`

   Concrete implementation of a csv interactor

   .. py:method:: load(self, **kwargs) -> pandas.DataFrame

      Parse 'path' as a pandas dataframe and return it

      Returns:
          pd.DataFrame: the parsed dataframe


   .. py:method:: save(self, asset: Union[pandas.DataFrame, pandas.Series], **kwargs)

      Save the 'data' dataframe as csv.

      Args:
          data (pandas.DataFrame): the dataframe to be saved



.. py:class:: XLSXInteractor(artifact, *args, session: statisfactory.session.BaseSession = None, **kwargs)

   Bases: :py:obj:`FileBasedInteractor`

   Concrete implementation of an XLSX interactor

   .. py:method:: load(self, **kwargs) -> pandas.DataFrame

      Parse 'path' as a pandas dataframe and return it

      Returns:
          pd.DataFrame: the parsed dataframe


   .. py:method:: save(self, asset: Union[pandas.DataFrame, pandas.Series], **kwargs)

      Save the 'data' dataframe as csv.

      Args:
          data (pandas.DataFrame): the dataframe to be saved



.. py:class:: PicklerInteractor(artifact, *args, session: statisfactory.session.BaseSession = None, **kwargs)

   Bases: :py:obj:`FileBasedInteractor`

   Concrete implementation of a Pickle interactor.

   .. py:method:: load(self, **kwargs) -> Any

      Unserialize the object located at 'path'

      Returns:
          Any: the unpickled object


   .. py:method:: save(self, asset: Any, **kwargs)

      Serialize the 'asset'

      Args:
          asset (Any ): the artifact to be saved



.. py:class:: ODBCInteractor(artifact, *args, session: statisfactory.session.BaseSession = None, **kwargs)

   Bases: :py:obj:`ArtifactInteractor`, :py:obj:`MixinParseInterpolate`

   Concrete implementation of an odbc interactor

   .. py:class:: Extra

      See https://docs.sqlalchemy.org/en/14/dialects/mssql.html#connecting-to-pyodbc
      for a complete description of the options

      .. py:attribute:: protocole
         :annotation: :str

         

      .. py:attribute:: username
         :annotation: :str

         

      .. py:attribute:: password
         :annotation: :str

         

      .. py:attribute:: host
         :annotation: :str

         

      .. py:attribute:: database
         :annotation: :str

         

      .. py:attribute:: URL_query
         :annotation: :Dict[str, str]

         

      .. py:attribute:: port
         :annotation: :Optional[Union[int, str]]

         

      .. py:attribute:: db_schema
         :annotation: :Optional[str]

         

      .. py:attribute:: table
         :annotation: :Optional[str]

         

      .. py:attribute:: query
         :annotation: :Optional[str]

         


   .. py:method:: _get_engine(self)

      Instanciate (and dispose off) the SQLAlchemy engine to be used for the query execution


   .. py:method:: load(self, **kwargs) -> pandas.DataFrame

      Parse 'path' as a pandas dataframe and return it
      Returns:
          pd.DataFrame: the parsed dataframe


   .. py:method:: save(self, asset: pandas.DataFrame, **kwargs)

      Save the DataFrame to the SQL server.



.. py:class:: DatapaneInteractor(artifact, *args, session: statisfactory.session.BaseSession = None, **kwargs)

   Bases: :py:obj:`FileBasedInteractor`

   Implements saving / loading for datapane object.

   .. py:method:: load(self, **kwargs)

      Not implemented since I don't want a report to be altered as for nowÂ­

      Raises:
          NotImplementedErrord


   .. py:method:: save(self, asset, **kwargs)

      Save a datapane assert

      Args:
          artifact (Report): the datapane report object to be saved.
          open (bool): whether open the report on saving.

      Implementation details:
      * The datapane file is first written to temp directory before being serialized back to bytes (I failled lamentably at finding how to extract the HTML from datapane)



.. py:class:: BinaryInteractor(artifact, *args, session: statisfactory.session.BaseSession = None, **kwargs)

   Bases: :py:obj:`FileBasedInteractor`

   Implements saving / loading for binary raw object

   .. py:method:: load(self, **kwargs)

      Return the content of a binary artifact.


   .. py:method:: save(self, asset: bytes, **kwargs)

      Save a datapane assert

      Args:
          artifact (Any): the binary content to write



.. py:class:: FeatherInteractor(artifact, *args, session: statisfactory.session.BaseSession = None, **kwargs)

   Bases: :py:obj:`FileBasedInteractor`

   Implements saving / loading for feather serialized object.
   Please : read https://arrow.apache.org/docs/python/feather.html to get a grasp of the Feather format.


   .. py:method:: load(self, **kwargs)

      Return the content of a feather artifact.


   .. py:method:: save(self, asset: Union[pandas.DataFrame, pandas.Series], **kwargs)

      Save a Feather asset

      Args:
          artifact Union[pd.DataFrame, pd.Series]: the dataframe content to write



