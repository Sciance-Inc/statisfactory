:py:mod:`statisfactory.IO`
==========================

.. py:module:: statisfactory.IO


Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   artifacts/index.rst


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   catalog/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   statisfactory.IO.ArtifactInteractor
   statisfactory.IO.Backend
   statisfactory.IO.MixinInterpolable
   statisfactory.IO.Catalog




.. py:class:: ArtifactInteractor(artifact, *args, session: statisfactory.session.BaseSession, **kwargs)

   Bases: :py:obj:`statisfactory.logger.MixinLogable`, :py:obj:`MixinInterpolable`

   Describe the Interactor's interface.
   An interactor wraps the loading and saving operations of a Artifact.
   The user can implements custom interactors. To do so, the user should
   implements the interface desbribes in this class. An artifact and a Session object
   are available when the artifact is called by the Catalog.

   Validation of the Extra parameter is possible through the definition of an inner class named Extra.
   The inner class schould be a pydantic dataclasse or a pydantic base model to allow for automatic validation.

   .. py:attribute:: Extra
      

      

   .. py:attribute:: _interactors
      

      

   .. py:method:: __init_subclass__(cls, interactor_name, register: bool = True, **kwargs)
      :classmethod:

      Implement the registration of a child class into the artifact class.
      By doing so, the ArtifactInteractor can be extended to use new interactors without updating the code of the class (Open Close principle)
      See PEP-487 for details.


   .. py:method:: _dispatch(self, callable: Callable, **kwargs) -> Dict[str, Any]

      Dispatch the variadic arguments the callable.

      Args:
          callable (Callable): The callable to dispatch arguments to.


   .. py:method:: interactors(cls)
      :classmethod:


   .. py:method:: load(self, **kwargs) -> Any
      :abstractmethod:

      Return the underlying asset.


   .. py:method:: save(self, asset: Any, **kwargs)
      :abstractmethod:

      Save the underlying asset.



.. py:class:: Backend(session: statisfactory.session.BaseSession, logger_name: str = __name__)

   Bases: :py:obj:`statisfactory.logger.MixinLogable`

   Interface for the low level communication with a service (s3, lakefs...) through the exchange of Bytes
   The backend consume and returns Bytes.

   .. py:attribute:: _backends
      

      

   .. py:method:: __init_subclass__(cls, prefix: str, **kwargs)
      :classmethod:

      Implement the registration of a child class into the backend class.
      By doing so, the Backend can be extended to use new interactors without updating the code of the class (Open Close principle)
      See PEP-487 for details.

      Args:
          prefix (str): The prefix to register the backend under

      Raises:
          Errors.E0201: Raised if the prefix has already a backend registered under,


   .. py:method:: backends(cls: Type[Backend]) -> Dict[str, Type[Backend]]
      :classmethod:

      Getter for the registered backends

      Returns:
          Map[str, Type[Backend]]: A mapping of prefixes associated with their respectives backend.


   .. py:method:: put(self, *, payload: bytes, fragment: urllib.parse.ParseResult, **kwargs)
      :abstractmethod:

      Drop the payload to the service under the 'path' name.

      Args:
          payload (bytes): The bytes representation of the artifact to drop on the backend.
          fragment (ParseResult): The Artifact's path parsed result to use to put the payload to.


   .. py:method:: get(self, *, fragment: urllib.parse.ParseResult, **kwargs) -> bytes
      :abstractmethod:

      Get the payload from the service under the 'path' name.

      Args:
          fragment (ParseResult): The Artifact's path parsed result to use to fetch the payload from.



.. py:class:: MixinInterpolable(*args, **kwargs)

   Implements helpers to interpolate a string

   .. py:method:: _interpolate_string(self, string, **kwargs)

      Interpolate a given string using the provided context



.. py:class:: Catalog(*, path: pathlib.Path, session: statisfactory.session.BaseSession = None)

   Bases: :py:obj:`statisfactory.logger.MixinLogable`

   Catalog represent a loadable / savable set of dataframes living locally or in far, far aways distributed system.

   .. py:method:: artifacts(self)
      :property:


   .. py:method:: __str__(self)

      Show all artifacts entries


   .. py:method:: __contains__(self, name: str) -> bool

      Check if the given name is an artifact


   .. py:method:: _get_artifact(self, name: str) -> statisfactory.models.models.Artifact

      Retrieve the FIRST artifact matching the given name currently living in the catalog.


   .. py:method:: _get_interactor(self, artifact: statisfactory.models.models.Artifact) -> Callable

      Retrieve the interactor matchin the type of the artifact.


   .. py:method:: load(self, name: str, **context) -> pandas.DataFrame

      Load an asset from the catalogue.
      A context can be provided through named variadic args.
      if a context is provided, the update of the context won't raised any error

      Args:
          name (str): the name of the artifact to load.


   .. py:method:: save(self, name: str, asset: Any, **context)

      Save the asset using the artifact name.
      A context can be provided through named variadic args.
      if a context is provided, the update of the context won't raised any error

      Args:
          name (str): the name of the arteface
          asset (Any): the underlying artifact to store


   .. py:method:: __add__(self, other: Any)

      Implements the visitor pattern for the catalog

      Args:
          other (Any): The right object to add


   .. py:method:: visit_catalog(self, other: Catalog) -> Catalog

      Implements the visitor pattern for the catalog. Combining two catalogs results in a merged catalog.

      Args:
          other (Catalog): The other catalogi to combine with

      Raise:
          Errors.E033: if two artifacts keys collide.



